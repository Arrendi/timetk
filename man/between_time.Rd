% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dplyr-between_time.R
\name{between_time}
\alias{between_time}
\title{Flexible range filtering for date or date-time sequences}
\usage{
between_time(.index, .start = "start", .end = "end")
}
\arguments{
\item{.index}{A date or date-time vector.}

\item{.start}{The starting date}

\item{.end}{The ending date}
}
\description{
The easiest way to filter time series date or date-time vectors. See \code{\link[=filter_by_time]{filter_by_time()}}
for the \code{data.frame} (\code{tibble}) implementation.
}
\details{
\strong{Pure Time Series Filtering Flexibilty}

The \code{.start}  and \code{.end} parameters are designed with flexibility in mind.

Each side of the \code{time_formula} is specified as the character
\code{'YYYY-MM-DD HH:MM:SS'}, but powerful shorthand is available.
Some examples are:
\itemize{
\item \strong{Year:} \verb{.start = '2013', .end = '2015'}
\item \strong{Month:} \verb{.start = '2013-01', .end = '2016-06'}
\item \strong{Day:} \verb{.start = '2013-01-05', .end = '2016-06-04'}
\item \strong{Second:} \verb{.start = '2013-01-05 10:22:15', .end = '2018-06-03 12:14:22'}
\item \strong{Variations:} \verb{.start = '2013', .end = '2016-06'}
}

\strong{Key Words: "start" and "end"}

Use the keywords "start" and "end" as shorthand, instead of specifying the
actual start and end values. Here are some examples:
\itemize{
\item \strong{Start of the series to end of 2015:} \verb{.start = 'start', .end = '2015'}
\item \strong{Start of 2014 to end of series:} \verb{.start = '2014', .end = 'end'}
}

\strong{Internal Calculations}

All shorthand dates are expanded:
\itemize{
\item The \code{.start} is expanded to be the \emph{first date} in that period
\item The \code{.end} side is expanded to be the \emph{last date} in that period
}

This means that the following examples are equivalent (assuming your
index is a POSIXct):
\itemize{
\item \code{.start = '2015'} is equivalent to \code{.start = '2015-01-01 + 00:00:00' }
\item \code{.end = '2016'} is equivalent to \verb{2016-12-31 + 23:59:59'}
}
}
\examples{
library(tidyverse)
library(tidyquant)
library(timetk)

index_daily <- tk_make_date_sequence("2016-01-01", "2017-01-01", by = "day")
index_min   <- tk_make_date_sequence("2016-01-01", "2017-01-01", by = "min")

# How it works
# - Returns TRUE/FALSE length of .index
# - Use sum() to tally the number of TRUE values
index_daily \%>\% between_time("start", "2016-01") \%>\% sum()

# ---- INDEX SLICING ----

# Daily Series: Month of January 2016
index_daily[index_daily \%>\% between_time("start", "2016-01")]

# Daily Series: March 1st - June 15th, 2016
index_daily[index_daily \%>\% between_time("2016-03", "2016-06-15")]

# Minute Series:
index_min[index_min \%>\% between_time("2016-02-01 12:00", "2016-02-01 13:00")]

# ---- FILTERING WITH DPLYR ----
FANG \%>\%
    group_by(symbol) \%>\%
    filter(date \%>\% between_time("2016-01", "2016-01"))

}
\seealso{
\itemize{
\item \code{\link[=filter_by_time]{filter_by_time()}} - A time-based variant of \code{dplyr::filter()} that is powered by
\code{between_time()}
\item \code{between_time()} is a vectorized function based on \code{tibbletime::filter_time()}
}
}
