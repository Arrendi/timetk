---
title: "sweep and dplyr: Forecasting in the tidyverse"
author: "Matt Dancho"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{sweep and dplyr - Forecasting in the tidyverse}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(
    # message = FALSE,
    # warning = FALSE,
    fig.width = 8, 
    fig.height = 4.5,
    fig.align = 'center',
    out.width='95%', 
    dpi = 200
)
library(tidyquant)
library(sweep)
library(forecast)
# devtools::load_all() # Travis CI fails on load_all()
```

> A "tidy" toolkit for forecasting and time series analysis

One of the most powerful things about `sweep` is that it makes forecasting at scale possible within the "tidyverse". There are two common situations:

1. Applying a model to many time series
2. Applying many models to a time series

We'll take a look at how `sweep` can help both of these situations.

# Prerequisites

Before we get started, load the following packages.

```{r, eval = F}
library(forecast)
library(tidyquant)
library(sweep)
```

# Cannondale Bike Sales

We'll use the bike sales data set, `bike_sales`, provided with the `sweep` package for this tutorial. The `bike_sales` data set is a _fictional_ daily order history that spans 2011 through 2015. It simulates a sales database that is typical of a business. The customers are the "bike shops" and the products are the "models".  

```{r}
bike_sales
```

We'll analyse the monthly sales trends for the bicycle manufacturer. Let's transform the data set by aggregating by month.

```{r}
bike_sales_monthly <- bike_sales %>%
    mutate(month = month(order.date, label = TRUE),
           year  = year(order.date)) %>%
    group_by(year, month) %>%
    summarise(total.qty = sum(quantity)) 
bike_sales_monthly
```


We can visualize package with a month plot using the `ggplot2` .

```{r}
bike_sales_monthly %>%
    ggplot(aes(x = month, y = total.qty, group = factor(year))) +
    geom_area(aes(fill = year), position = "stack") +
    labs(title = "Quantity Sold: Month Plot", x = "", y = "Sales",
         subtitle = "March through July tend to be most active") +
    scale_y_continuous() +
    theme_tq()
```

Suppose manufacturing wants a more granular forecast because the bike components tend to vary by the secondary category. In the next section we discuss how `sweep` can help to perform a forecast on each sub-category.


# Performing Forecasts on Groups

First, we need to get the data organized into groups. We'll create a new "order.yearmon" date using `zoo::as.yearmon()` that captures the year and month information from the "order.date". The `yearmon` class is needed to coerce to a `ts` down the road. 

```{r}
qty_by_cat2 <- bike_sales %>%
    mutate(order.yearmon = as.yearmon(order.date)) %>%
    group_by(category.secondary, order.yearmon) %>%
    summarise(total.qty = sum(quantity))
qty_by_cat2
```

Next, we use the `nest()` function from the `tidyr` package to consolidate each time series by group. The newly created "data" list-column contains the "order.yearmon" and "total.qty" columns by group.

```{r}
qty_by_cat2_nest <- qty_by_cat2 %>%
    group_by(category.secondary) %>%
    nest()
qty_by_cat2_nest
```

## Forecasting Workflow

The forecasting workflow involves a few basic steps:

1. Step 1: Coerce to a `ts` object class.
2. Step 2: Apply a model (or set of models)
3. Step 3: Forecast the models (similar to predict)

In each step of the workflow we'll see how `sweep` can help.

## Step 1: Coerce to a `ts` object class

In this step we map the `sw_ts()` function into a new column "data.ts" using the combination of `dplyr::mutate()` and `purrr::map()`. The `mutate()` function adds a column, and the `map()` function maps the contents of a list-column (`.x`) to a function (`.f`). In our case, `.x = data` and `.f = ~ sw_ts(.x, select = -order.yearmon, start = 2011, freq = 12)`. The `select` statement is used to drop the "order.yearmon" from the final output so we don't get a bunch of warning messages. We specify `start = 2011` and `freq = 12` to return a monthly frequency.

```{r}
qty_by_cat2_ts <- qty_by_cat2_nest %>%
    mutate(data.ts = map(.x = data, 
                         .f = ~ sw_ts(.x, 
                                      select   = -order.yearmon, 
                                      start    = 2011,
                                      freq     = 12)))
qty_by_cat2_ts
```


## Step 2: Modeling a time series

Next, we map a model function from the `forecast` package. We'll use the `ets()` function to fit an Exponential Smoothing ETS (Error, Trend, Seasonal) model to each of the groups. Since we are not passing parameters, we can use shorthand for `.f = ets`. 

```{r}
qty_by_cat2_fit <- qty_by_cat2_ts %>%
    mutate(fit.ets = map(.x = data.ts, .f = ets))
qty_by_cat2_fit
```

At this point, we can do some model inspection with the `sweep` tidiers.

### sw_tidy

Use `sw_tidy` to get the model parameters.

```{r}
qty_by_cat2_fit %>%
    mutate(fit.tidy = map(fit.ets, sw_tidy)) %>%
    unnest(fit.tidy) %>%
    spread(key = category.secondary, value = estimate)
```

### sw_glance



Use `sw_glance` to inspect 


## Step 3: Forecasting the model



