---
title: "Introduction to sweep"
author: "Matt Dancho"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Introduction to sweep}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(
    # message = FALSE,
    # warning = FALSE,
    fig.width = 8, 
    fig.height = 4.5,
    fig.align = 'center',
    out.width='95%', 
    dpi = 200
)
library(tidyquant)
library(sweep)
library(forecast)
# devtools::load_all() # Travis CI fails on load_all()
```

> A "tidy" toolkit for forecasting and time series analysis

The `sweep` package combines a collection of tools for performing forecasts and time series analysis in the "tidyverse". While the package is geared towards the workflow required to perform forecasts using Rob Hyndman's `forecast` package, it contains elements that can help when performing time series analysis using time-based tibbles (`tbl`). The package contains the following elements:

1. __forecast tidier__: `sw_sweep` converts a `forecast` object to a tibble that can be easily manipulated in the "tidyverse".

2. __broom model tidiers__: `sw_tidy`, `sw_glance`, `sw_augment`, `sw_tidy_decomp` functions extend `tidy`, `glance`, and `augment` from the `broom` package specifically for models (`ets()`, `Arima()`, `bats()`, etc) used for forecasting.

3. __coercion functions__: `sw_tbl`, `sw_ts`, `sw_xts`, `sw_zoo`, and `sw_zooreg` coerce time-based tibbles `tbl` to and from each of the main time-series data types `xts`, `zoo`, `zooreg`, `ts`, maintaining the time-based index.

4. __unroll function__: `sw_unroll_index` returns the original time series index of `forecast`objects, models, and `ts` objects. Only applicable to `ts` objects coerced using the `sw_ts()` function on data objects with a time-based index (e.g. `tbl`, `xts`, `zoo`).  

To illustrate, let's take a basic forecasting workflow starting from data collected in a tibble format and then performing some basic processes to achieve a forecast in tibble format.

# Prerequisites

Before we get started, load the following packages.

```{r, eval = F}
library(forecast)
library(tidyquant)
library(sweep)
```

# Forecasting Sales of Beer, Wine, and Distilled Alcohol Beverages

We'll use the `tidyquant` package to get the US alcohol sales, which comes from the FRED data base (the origin is the US Bureau of the Census, one of the 80+ data sources FRED connects to). The FRED code is "S4248SM144NCEN" and the data set can be found [here](https://fred.stlouisfed.org/series/S4248SM144NCEN).

```{r}
alcohol_sales_tbl <- tq_get("S4248SM144NCEN", 
                            get  = "economic.data", 
                            from = "2007-01-01",
                            to   = "2016-12-31")
alcohol_sales_tbl
```

We can quickly visualize using the `ggplot2` package. We can see that there appears to be some seasonality and an upward trend.

```{r}
alcohol_sales_tbl %>%
    ggplot(aes(x = date, y = price)) +
    geom_line(size = 1, color = palette_light()[[1]]) +
    geom_smooth() +
    labs(title = "US Alcohol Sales: Monthly", x = "", y = "Millions") +
    scale_y_continuous(labels = scales::dollar) +
    scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
    theme_tq()
```


# Forecasting Workflow

The forecasting workflow involves a few basic steps:

1. Step 1: Coerce to a `ts` object class.
2. Step 2: Apply a model (or set of models)
3. Step 3: Forecast the models (similar to predict)

In each step of the workflow we'll see how `sweep` can help.

_Note that we purposely omit other steps such as testing the series for stationarity (`Box.test(type = "Ljung")`) and analysis of autocorrelations (`Acf`, `Pacf`) for brevity purposes._

## Step 1: Coerce to a `ts` object class

The `forecast` package uses the `ts` data structure, which is quite a bit different than tibbles that we are currently using. Fortunately, it's easy to get to the correct structure with `sw_ts()` (Refer to [SW03 Extensible Time Series Coercion Using sweep]()] for the benefits).  


```{r}
alcohol_sales_ts <- sw_ts(alcohol_sales_tbl, start = 2007, freq = 12)
alcohol_sales_ts
```

Now that a time series has been coerced, let's proceed with modeling.

## Step 2: Modeling a time series

The modeling workflow takes a time series object and applies a model. Nothing new here: we'll simply use the `ets()` function from the `forecast` package to get an Exponential Smoothing ETS (Error, Trend, Seasonal) model.

```{r}
fit_ets <- alcohol_sales_ts %>%
    ets()
```

Where `sweep` can help is in the evaluation of a model. Expanding on the `broom` package there are four functions:

* `sw_tidy()`: Returns a tibble of model parameters
* `sw_glance()`: Returns the model accuracy measurements
* `sw_augment()`: Returns the fitted and residuals of the model
* `sw_tidy_decomp()`: Returns a tidy decomposition from a model

The guide below shows which modeling functions are compatible with which `sweep` tidier functions.

```{r, echo = F}
tibble::tribble(
    ~Function,       ~`sw_tidy()`, ~`sw_glance()`, ~`sw_augment()`, ~`sw_tidy_decomp()`,
    "ar()",          "",  "",  "", "",
    "arima()",       "X", "X", "X", "",
    "Arima()",       "X", "X", "X", "",
    "ets()",         "X", "X", "X", "X",
    "baggedETS()",   "",  "",  "",  "",
    "bats()",        "X", "X", "X", "X",
    "tbats()",       "X", "X", "X", "X",
    "nnetar()",      "X", "X", "X", "",
    "stl()",         "",  "",  "",  "X",
    "HoltWinters()", "X", "X", "X", "X",
    "StructTS",      "X", "X", "X", "X",
    "tslm()",        "X", "X", "X", "",
    "decompose()",   "",  "",  "",  "X",
    "adf.test()",    "X", "X", "",  "",
    "Box.test()",    "X", "X", "",  "",
    "kpss.test()",   "X", "X", "",  ""
) %>%
    knitr::kable(caption = "Function Compatibility: sw_tidy, sw_glance, sw_augment, sw_tidy_decomp",
                 align = c("l", "c", "c", "c", "c"))
```


Going through the tidiers, we can get useful `model` information. 

### sw_tidy

`sw_tidy()` returns the model parameters.

```{r}
sw_tidy(fit_ets)
```

### sw_glance

`sw_glance()` returns the model quality parameters.

```{r}
sw_glance(fit_ets)
```

### sw_augment

`sw_augment()` returns the actual, fitted and residual values.

```{r}
augment_fit_ets <- sw_augment(fit_ets)
augment_fit_ets
```

We can review the residuals to determine if their are any underlying patterns left. The index date is regularized meaning that it's a numeric value with the point during the year identified as a numeric value (e.g. 2007.833 is the equivalent of January 2007). The `yearmon` function from the zoo package can be used to convert to a human readible Jan 2007. The `geom_ma()` function from `tidyquant` is used to add a moving average, which can be used to spot remaining pattern. 

```{r}
augment_fit_ets %>%
    ggplot(aes(x = yearmon(index), y = .resid)) +
    geom_hline(yintercept = 0, color = "grey40") +
    geom_line(color = palette_light()[[2]]) +
    geom_point() +
    geom_ma(ma_fun = SMA, n = 12, size = 1) +
    scale_x_yearmon(n = 10) +
    labs(title = "US Alcohol Sales: ETS Residuals", x = "") + 
    theme_tq()
```


### sw_tidy_decomp

`sw_tidy_decomp()` returns the decomposition of the ETS model.

```{r}
decomp_fit_ets <- sw_tidy_decomp(fit_ets)
decomp_fit_ets 
```

We can review the decomposition using `ggplot2` as well.  The data will need to be manipulated slightly for the facet visualization. The `gather()` function from the `tidyr` package is used to reshape the data into a long format data frame with column names "key" and "value" indicating all columns except for index are to be reshaped. The "key" column is then mutated using `mutate()` to a factor which preserves the order of the keys so "observed" comes first when plotting. 

```{r}
decomp_fit_ets %>%
    gather(key = key, value = value, -index) %>%
    mutate(key = forcats::as_factor(key)) %>%
    ggplot(aes(x = yearmon(index), y = value, group = key)) +
    geom_line(color = palette_light()[[2]]) +
    geom_ma(ma_fun = SMA, n = 12, size = 1) +
    facet_wrap(~ key, scales = "free_y") +
    scale_x_yearmon(n = 10) +
    labs(title = "US Alcohol Sales: ETS Decomposition", x = "") + 
    theme_tq() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Under normal circumstances it would make sense to refine the model at this point. However, in the interest of showing capabilities (rather than how to forecast) we move onto forecasting the model. For more information on how to forecast, please refer to the online book [_"Forecasting: Principles and Practices"_](https://www.otexts.org/book/fpp). 

## Step 3: Forecasting the model

We'll use the `sw_sweep()` function to coerce a `forecast` into a usable data frame. The `forecast()` function is similar to `predict` from the `stats` package in that it creates a forecast (or prediction) from the ETS model, `fit_ets`. We set the `forecast(h = 12)` to yield a 12 month forecast. The `sw_sweep()` function then coerces the `forecast` object into a tibble that can be sent to `ggplot` for visualization. The tibble return contains "key" and "value" (or in this case "price") that are tidy columns with the values of "key" being "Actual" and "Forecast". The `sw_sweep` argument contains a parameter `.fitted` that is `TRUE` by default meaning that the "Forecast" values contain the fitted model as well (We'll see how you can toggle this off in the next graph). The remaining columns are the forecast confidence intervals (typically 80 and 95, but this can be changed with `forecast(level = c(80, 95))`). These columns are setup to enable using the `geom_ribbon()` for visualization purposes.

```{r}
fcast_ets <- fit_ets %>%
    forecast(h = 12) 
    
sw_sweep(fcast_ets)
```

We can visualize using a combination of `geom_line()` and `geom_ribbon()`. The fitted values can be toggled off using `sw_sweep(.fitted = FALSE)`.

```{r}
sw_sweep(fcast_ets, .fitted = FALSE) %>%
    ggplot(aes(x = yearmon(index), y = price, color = key)) +
    geom_ribbon(aes(ymin = lo.95, ymax = hi.95), 
                fill = "#D5DBFF", color = NA, size = 0) +
    geom_ribbon(aes(ymin = lo.80, ymax = hi.80, fill = key), 
                fill = "#596DD5", color = NA, size = 0, alpha = 0.8) +
    geom_line(size = 1) +
    labs(title = "US Alcohol Sales", subtitle = "ETS Model Forecast", x = "", y = "Millions") +
    scale_y_continuous(labels = scales::dollar) +
    scale_x_yearmon(n = 12, format = "%Y") +
    scale_color_tq() +
    scale_fill_tq() +
    theme_tq() 
```

# Recap

This was a brief overview of how various functions within the `sweep` package can be used to assist in forecasting and time series analysis. In the next vignette, we discuss some more powerful concepts including forecasting at scale with grouped time series analysis. 

