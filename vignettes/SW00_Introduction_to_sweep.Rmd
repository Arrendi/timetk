---
title: "Introduction to sweep"
author: "Matt Dancho"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Introduction to sweep}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(
    # message = FALSE,
    # warning = FALSE,
    fig.width = 8, 
    fig.height = 4.5,
    fig.align = 'center',
    out.width='95%', 
    dpi = 200
)
library(tidyquant)
library(sweep)
library(forecast)
# devtools::load_all() # Travis CI fails on load_all()
```

> A "tidy" toolkit for forecasting and time series analysis

The `sweep` package combines a set of tools for performing forecasts and time series analysis in the "tidyverse". While the package is geared towards the workflow required to perform forecasts using Rob Hyndman's `forecast` package, it contains elements that can help when performing time series analysis using tibbles ("tidy" data frames). The package contains three basic elements:

1. __Coercion functions__: `sw_tbl`, `sw_ts`, `sw_xts`, `sw_zoo`, and `sw_zooreg`. These functions coerce time-based tibbles `tbl` to and from each of the main time-series data types `xts`, `zoo`, `zooreg`, `ts`, maintaining the time-based index.

2. __broom model tidiers__: `sw_tidy`, `sw_glance`, `sw_augment`, `sw_tidy_decomp`. These functions extend `tidy`, `glance`, and `augment` from the `broom` package specifically for models (`ets()`, `Arima()`, `bats()`, etc) used for forecasting.

3. __Forecast tidier__: `sw_sweep`. A function that converts a `forecast` to a tibble that can be easily manipulated in the "tidyverse".

To illustrate, let's take a basic forecasting workflow starting from data collected in a tibble format and then performing some basic processes to achieve a forecast in tibble format.

# Prerequisites

Before we get started, load the following packages.

```{r, eval = F}
library(forecast)
library(tidyquant)
library(sweep)
```

# Forecasting Sales of Beer, Wine, and Distilled Alcohol Beverages

We'll use the `tidyquant` package to get the US alcohol sales, which comes from the FRED data base (the origin is the US Bureau of the Census, one of the 80+ data sources FRED connects to). The FRED code is "S4248SM144NCEN" and the data set can be found [here](https://fred.stlouisfed.org/series/S4248SM144NCEN).

```{r}
alcohol_sales_tbl <- tq_get("S4248SM144NCEN", 
                            get  = "economic.data", 
                            from = "2007-01-01",
                            to   = "2016-12-31")
alcohol_sales_tbl
```

We can quickly visualize using the `ggplot2` package. We can see that there appears to be some seasonality and an upward trend.

```{r}
alcohol_sales_tbl %>%
    ggplot(aes(x = date, y = price)) +
    geom_line(size = 1, color = palette_light()[[1]]) +
    geom_smooth() +
    labs(title = "US Alcohol Sales: Monthly", x = "", y = "Millions") +
    scale_y_continuous(labels = scales::dollar) +
    scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
    theme_tq()
```


# Forecasting Workflow

The forecasting workflow involves a few basic steps:

1. Step 1: Coerce to a `ts` object class.
2. Step 2: Apply a model (or set of models)
3. Step 3: Forecast the models (similar to predict)

In each step of the workflow we'll see how `sweep` can help.

## Step 1: Coerce to a `ts` object class

The `forecast` package uses the `ts` data structure, which is quite a bit different than tibbles that we are currently using. Fortunately, it's easy to get to the correct structure. We can do this a couple ways. First, we'll take a look at the current way using `stats::ts()`. 

### stats::ts

This procedure works, but there's a few things the user needs to be aware of. First, only numeric columns get coerced. If the user forgets to add the `[,-1]` to drop the "date" column, `ts()` returns dates in numeric format which is not what the user wants. 

```{r}
alcohol_sales_ts_stats <- ts(alcohol_sales_tbl[,-1], start = 2007, freq = 12)
alcohol_sales_ts_stats
```

Second, the results do not retain the original index (a vector of dates). Only a regularized time series is maintained in numeric format meaning that the date information is lost. 

```{r}
str(alcohol_sales_ts_stats)
```

### sweep::sw_ts

Now using the new function, `sw_ts()`, we can see a few differences. First, only numeric columns get coerced, which prevents unintended consequences due to R coercion rules (e.g. dates getting unintentionally converted or characters causing numeric to be coerced). If a column is dropped, the user gets a warning. 

```{r}
alcohol_sales_ts <- sw_ts(alcohol_sales_tbl, start = 2007, freq = 12)
alcohol_sales_ts
```

Second, the data returned has a few additional attributes. The most important of which is a numeric attribute, "index", which contains the original date information as a number. The `ts()` function will not preserve this index while `sw_ts()` will in numeric form. 

```{r}
str(alcohol_sales_ts)
```

We can extract the original index in date format using `sw_index()`.

```{r}
index <- sw_index(alcohol_sales_ts)
head(index)
class(index)
```

Now that a time series has been coerced, let's proceed with modeling.

## Step 2: Modeling a time series

The modeling workflow takes a time series object and applies a model. Nothing new here: we'll simply use the `ets()` function from the `forecast` package to get an Exponential Smoothing ETS (Error, Trend, Seasonal) model.

```{r}
fit_ets <- alcohol_sales_ts %>%
    ets()
```

Where `sweep` can help is in the evaluation of a model. Expanding on the `broom` package there are four functions:

* `sw_tidy()`: Returns a tibble of model parameters
* `sw_glance()`: Returns the model accuracy measurements
* `sw_augment()`: Returns the fitted and residuals of the model
* `sw_tidy_decomp()`: Returns a tidy decomposition from a model

The guide below shows which modeling functions are compatible with which `sweep` tidier functions.

```{r, echo = F}
tibble::tribble(
    ~Function,       ~`sw_tidy()`, ~`sw_glance()`, ~`sw_augment()`, ~`sw_tidy_decomp()`,
    "ar()",          "",  "",  "", "",
    "arima()",       "X", "X", "X", "",
    "Arima()",       "X", "X", "X", "",
    "ets()",         "X", "X", "X", "X",
    "baggedETS()",   "",  "",  "",  "",
    "bats()",        "X", "X", "X", "X",
    "tbats()",       "X", "X", "X", "X",
    "nnetar()",      "X", "X", "X", "",
    "stl()",         "",  "",  "",  "X",
    "HoltWinters()", "X", "X", "X", "X",
    "StructTS",      "X", "X", "X", "X",
    "tslm()",        "X", "X", "X", "",
    "decompose()",   "",  "",  "",  "X",
    "adf.test()",    "X", "X", "",  "",
    "Box.test()",    "X", "X", "",  "",
    "kpss.test()",   "X", "X", "",  ""
) %>%
    knitr::kable(caption = "Function Compatibility: sw_tidy, sw_glance, sw_augment, sw_tidy_decomp",
                 align = c("l", "c", "c", "c", "c"))
```


Going through the tidiers, we can get useful `model` information. 

### sw_tidy

`sw_tidy()` returns the model parameters.

```{r}
sw_tidy(fit_ets)
```

### sw_glance

`sw_glance()` returns the model quality parameters.

```{r}
sw_glance(fit_ets)
```

### sw_augment

`sw_augment()` returns the actual, fitted and residual values.

```{r}
augment_fit_ets <- sw_augment(fit_ets)
augment_fit_ets
```

We can review the residuals to determine if their are any underlying patterns left. The index date is regularized meaning that it's a numeric value with the point during the year identified as a numeric value (e.g. 2007.833 is the equivalent of January 2007). The `yearmon` function from the zoo package can be used to convert to a human readible Jan 2007. The `geom_ma()` function from `tidyquant` is used to add a moving average, which can be used to spot remaining pattern. 

```{r}
augment_fit_ets %>%
    ggplot(aes(x = yearmon(index), y = .resid)) +
    geom_hline(yintercept = 0, color = "grey40") +
    geom_line(color = palette_light()[[2]]) +
    geom_point() +
    geom_ma(ma_fun = SMA, n = 12, size = 1) +
    scale_x_yearmon(n = 10) +
    labs(title = "US Alcohol Sales: ETS Residuals", x = "") + 
    theme_tq()
```


### sw_tidy_decomp

`sw_tidy_decomp()` returns the decomposition of the ETS model.

```{r}
decomp_fit_ets <- sw_tidy_decomp(fit_ets)
decomp_fit_ets 
```

We can review the decomposition using `ggplot2` as well.  The data will need to be manipulated slightly for the facet visualization. The `gather()` function from the `tidyr` package is used to reshape the data into a long format data frame with column names "key" and "value" indicating all columns except for index are to be reshaped. The "key" column is then mutated using `mutate()` to a factor which preserves the order of the keys so "observed" comes first when plotting. 

```{r}
decomp_fit_ets %>%
    gather(key = key, value = value, -index) %>%
    mutate(key = forcats::as_factor(key)) %>%
    ggplot(aes(x = yearmon(index), y = value, group = key)) +
    geom_line(color = palette_light()[[2]]) +
    geom_ma(ma_fun = SMA, n = 12, size = 1) +
    facet_wrap(~ key, scales = "free_y") +
    scale_x_yearmon(n = 10) +
    labs(title = "US Alcohol Sales: ETS Decomposition", x = "") + 
    theme_tq() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Under normal circumstances it would make sense to refine the model at this point. However, in the interest of showing capabilities (rather than how to forecast) we move onto forecasting the model. For more information on how to forecast, please refer to the online book [_"Forecasting: Principles and Practices"_](https://www.otexts.org/book/fpp). 

## Step 3: Forecasting the model

We'll use the `sw_sweep()` function to coerce a `forecast` into a usable data frame. The `forecast()` function is similar to `predict` from the `stats` package in that it creates a forecast (or prediction) from the ETS model, `fit_ets`. We set the `forecast(h = 12)` to yield a 12 month forecast. The `sw_sweep()` function then coerces the `forecast` object into a tibble that can be sent to `ggplot` for visualization. 

```{r}
fcast_ets <- fit_ets %>%
    forecast(h = 12) 
    
sweep_ets <- sw_sweep(fcast_ets)
sweep_ets
```

We can visualize using a combination of `geom_line()` and `geom_ribbon()`.

```{r}
sweep_ets %>%
    ggplot(aes(x = yearmon(index), y = price, color = key)) +
    geom_ribbon(aes(ymin = lo.95, ymax = hi.95), 
                fill = "#D5DBFF", color = NA, size = 0) +
    geom_ribbon(aes(ymin = lo.80, ymax = hi.80, fill = key), 
                fill = "#596DD5", color = NA, size = 0, alpha = 0.8) +
    geom_line(size = 1) +
    labs(title = "US Alcohol Sales", subtitle = "ETS Model Forecast", x = "", y = "") +
    scale_y_continuous(labels = scales::dollar) +
    scale_x_yearmon(n = 12, format = "%Y") +
    scale_color_tq() +
    scale_fill_tq() +
    theme_tq() 
```

# Recap

This was a brief overview of how various functions within the `sweep` package can be used to assist in forecasting and time series analysis. In the next vignette, we discuss some more powerful concepts including forecasting at scale with grouped time series analysis. 

