#' Coerce time-series objects to tibble.
#'
#' @param data A time-series object.
#' @param preserve_index Attempts to preserve a time series index. Default is `TRUE`.
#' @param index_rename Enables the index column to be renamed.
#' @param .unroll Used when unrolling `ts` objects that contain date or datetime
#' "index" attribute.
#' Refer to [sw_unroll_index()] for more information on returning index information
#' from regularized timeseries objects (i.e. `ts`).
#' @param ... Additional parameters passed to the [tibble::as_tibble()] function.
#'
#' @return Returns a `tibble` object.
#'
#' @details `sw_tbl` is designed
#' to coerce time series objects (e.g. `xts`, `zoo`, `ts`, `timeSeries`, etc)
#' to `tibble` objects. The main advantage is that the function keeps the
#' date / date-time information from the underlying time-series object.
#'
#' When `preserve_index = TRUE` is specified, a new column,
#' `index`, is created during object coercion, and the function attempts to preserve
#' the date or date-time information. The date / date-time column name
#' can be changed using the `index_rename` argument.
#'
#' The `.unroll` argument is applicable when coercing `ts` objects that were
#' created using `sw_ts()` from an object that had a time base
#' (e.g. `tbl`, `xts`, `zoo`).
#' Setting `.unroll = TRUE` enables unrolling the original index.
#'
#' @seealso [sw_xts()], [sw_zoo()], [sw_zooreg()], [sw_ts()]
#'
#' @examples
#' library(tidyverse)
#' library(sweep)
#'
#' data_tbl <- tibble(
#'     date = seq.Date(from = as.Date("2010-01-01"), by = 1, length.out = 5),
#'     x    = seq(100, 120, by = 5)
#' )
#'
#'
#' ### ts to tibble: Comparison between as.data.frame() and sw_tbl()
#' data_ts <- sw_ts(data_tbl, start = c(2010,1), freq = 365)
#'
#' # No index
#' as.data.frame(data_ts)
#'
#' # Regularized numeric index starting in 2015
#' sw_tbl(data_ts)
#'
#' # Original date index unrolled (Only possible if original data has time-based index)
#' sw_tbl(data_ts, .unroll = TRUE)
#'
#'
#' ### xts to tibble: Comparison between as.data.frame() and sw_tbl()
#' data_xts <- sw_xts(data_tbl)
#'
#' # Dates are character class stored in row names
#' as.data.frame(data_xts)
#'
#' # Dates are appropriate date class and within the data frame
#' sw_tbl(data_xts)
#'
#'
#' ### zooreg to tibble: Comparison between as.data.frame() and sw_tbl()
#' data_zooreg <- sw_zooreg(1:8, start = zoo::yearqtr(2000), frequency = 4)
#'
#' # Dates are character class stored in row names
#' as.data.frame(data_zooreg)
#'
#' # Dates are appropriate zoo yearqtr class within the data frame
#' sw_tbl(data_zooreg)
#'
#'
#' ### zoo to tibble: Comparison between as.data.frame() and sw_tbl()
#' data_zoo <- zoo::zoo(1:12, zoo::yearmon(2016 + seq(0, 11)/12))
#'
#' # Dates are character class stored in row names
#' as.data.frame(data_zoo)
#'
#' # Dates are appropriate zoo yearmon class within the data frame
#' sw_tbl(data_zoo)
#'
#'
#'
#'
#' @export
sw_tbl <- function(data, preserve_index = TRUE, index_rename = "index", .unroll = FALSE, ...) {
    UseMethod("sw_tbl", data)
}

#' @export
sw_tbl.data.frame <- function(data, preserve_index = TRUE, index_rename = "index", .unroll = FALSE, ...) {

    if (preserve_index == TRUE) {

        idx <- rownames(data)

        # Detect if row.names exist beyond sequential 1:nrow(x) or null value
        if (!is.null(idx) &&
            !identical(as.character(idx), as.character(1:nrow(as.data.frame(data))))
            ) {

            ret <- data %>%
                as.data.frame() %>%
                tibble::rownames_to_column(var = index_rename) %>%
                tibble::as_tibble()

            ret <- suppressMessages(readr::type_convert(ret))

        } else {

            warning("Warning: No index to preserve. Object otherwise converted to tibble successfully.")
            ret <- tibble::as_tibble(data, ...)
        }

    } else {

        ret <- tibble::as_tibble(data, ...)

    }

    return(ret)

}

#' @export
sw_tbl.xts <- function(data, preserve_index = TRUE, index_rename = "index", .unroll = FALSE, ...) {

    # Coerce to zoo, then to tbl
    ret <- sw_tbl(zoo::as.zoo(data), preserve_index, index_rename, ...)
    return(ret)
}

#' @export
sw_tbl.matrix <- function(data, preserve_index = TRUE, index_rename = "index", .unroll = FALSE, ...) {

    # Coerce to data frame, then to tbl
    ret <- sw_tbl(as.data.frame(data), preserve_index, index_rename, ...)
    return(ret)

}

#' @export
sw_tbl.zoo <- function(data, preserve_index = TRUE, index_rename = "index", .unroll = FALSE, ...) {

    if (preserve_index == TRUE) {

        if (!is.null(zoo::index(data))) {
            idx <- zoo::index(data)
        } else {
            idx = NULL
        }

        # Detect if row.names exist beyond sequential 1:nrow(x) or null value
        if (!is.null(idx) &&
            !identical(as.character(idx), as.character(1:nrow(as.data.frame(data))))
            ) {

            ret <- tibble::as_tibble(data, ...) %>%
                tibble::add_column(idx, .before = 1)

            if (!is.null(index_rename)) colnames(ret)[[1]] <- index_rename

            ret <- suppressMessages(readr::type_convert(ret))


        } else {

            warning(paste0("Warning: No index to preserve. ",
                           "Object otherwise converted to tibble successfully."))
            ret <- tibble::as_tibble(data, ...)
        }

    } else {

        ret <- tibble::as_tibble(data, ...)

    }

    return(ret)
}

#' @export
sw_tbl.zooreg <- function(data, preserve_index = TRUE, index_rename = "index", .unroll = FALSE, ...) {

    # Handle index unrolling
    if (.unroll && preserve_index) {

        # Index attribute found?
        first_val <- rownames(data)[[1]]
        if (!is.null(first_val)) {
            # Coerce to xts then to tbl
            index <- sw_unroll_index(data)
            ret <- sw_xts(data, order.by = index) %>%
                sw_tbl(preserve_index = preserve_index,
                       index_rename   = index_rename,
                       .unroll        = .unroll,
                       ...            = ...)
        } else {
            warning("No `index` attribute to unroll. Using regularized index.")
            ret <- sw_tbl(zoo::as.zoo(data), preserve_index, index_rename, ...)
        }

    } else {
        # Coerce to zoo then convert to tibble
        ret <- sw_tbl(zoo::as.zoo(data), preserve_index, index_rename, ...)
    }

    return(ret)
}

#' @export
sw_tbl.ts <- function(data, preserve_index = TRUE, index_rename = "index", .unroll = FALSE, ...) {

    # Handle index unrolling
    if (.unroll && preserve_index) {

        # Index attribute found?
        index_attr <- attr(data, "index")
        if (!is.null(index_attr)) {
            # Coerce to xts then to tbl
            index <- sw_unroll_index(data)
            ret <- sw_xts(data, order.by = index) %>%
                sw_tbl(preserve_index = preserve_index,
                       index_rename   = index_rename,
                       .unroll        = .unroll,
                       ...            = ...)
        } else {
            warning("No `index` attribute to unroll. Using regularized index.")
            ret <- sw_tbl(zoo::as.zoo(data), preserve_index, index_rename, ...)
        }

    } else {
        # Coerce to zoo then convert to tibble
        ret <- sw_tbl(zoo::as.zoo(data), preserve_index, index_rename, ...)
    }

    return(ret)
}

# mts handled via ts class


#' @export
sw_tbl.msts <- function(data, preserve_index = TRUE, index_rename = "index", .unroll = FALSE, ...) {

    # Coerce to zoo then convert to tibble
    ret <- sw_tbl(zoo::as.zoo(data), preserve_index, index_rename, ...)
    return(ret)
}

#' @export
sw_tbl.timeSeries <- function(data, preserve_index = TRUE, index_rename = "index", .unroll = FALSE, ...) {

    # Coerce to data frame, then to tbl (No index to coerce to zoo)
    ret <- sw_tbl(as.data.frame(data), preserve_index, index_rename, ...)
    return(ret)
}

#' @export
sw_tbl.irts <- function(data, preserve_index = TRUE, index_rename = "index", .unroll = FALSE, ...) {

    # Coerce to zoo then convert to tibble
    ret <- sw_tbl(zoo::as.zoo(data), preserve_index, index_rename, ...)
    return(ret)
}


#' @export
sw_tbl.default <- function(data, preserve_index = TRUE, index_rename = "index", .unroll = FALSE, ...) {

    tryCatch({
        # Attempt coercion to data.frame, then to tbl
        ret <- sw_tbl(as.data.frame(data), preserve_index, index_rename, ...)
        return(ret)
    }, error = function(e) {
        warning(paste0("Coercion unsuccessful. Function does not support class ", class(data)[[1]], ". ", e))
        return(data)
    })

}
