#' Extract an index of date or datetime from time series objects, models, forecasts
#'
#' @name sw_index
#'
#' @param data A time-based tibble, time-series object, time-series model,
#' or `forecast` object.
#' @param .sweep_idx
#' If `.sweep_idx` is `TRUE` a sweep time-based index attribute is attempted to be returned.
#' If `FALSE` the default index is returned. See discussion below for further details.
#'
#' @return Returns a vector of date or date times
#'
#' @details
#' `sw_index()` is used to extract the date or datetime index from various
#' time series objects, models and forecasts.
#' The method can additionally be used on `forecast` objects and a number of
#' objects generated by modeling functions such as `Arima`, `ets`, and `HoltWinters`
#' classes to get the index.
#'
#' The boolean `.sweep_idx` argument is applicable to regularized time series objects
#' such as `ts` and `zooreg` classes that have both a regularized index and _potentially_
#' a "sweep index" (a time-based attribute).
#' When set to `FALSE` the regularized index is returned.
#' When set to `TRUE` the time-based sweep index is returned _if present_.
#'
#' __Important Note__: To gain the benefit of `.sweep_idx` the time series
#' must have a sweep index. This is particularly important for `ts` objects, which
#' by default do not contain an index and therefore must be coerced from time-based
#' objects such as `tbl`, `xts`, or `zoo` using the `sw_ts()` function.
#' Refer to [sw_ts()] for creating persistent date / datetime index
#' during coercion to `ts`.
#'
#'
#'
#' @seealso [sw_ts()], [sw_tbl()], [sw_xts()], [sw_zoo()], [sw_zooreg()]
#'
#' @examples
#' library(tidyverse)
#' library(sweep)
#'
#' # Create time-based tibble
#' data_tbl <- tibble::tibble(
#'     date = seq.Date(from = as.Date("2000-01-01"), by = 1, length.out = 5),
#'     x    = rnorm(5) * 10,
#'     y    = 5:1
#' )
#' sw_index(data_tbl) # Returns time-based index vector
#'
#' # Coerce to ts using sw_ts(): Preserves time-basis
#' data_ts <- sw_ts(data_tbl)
#' sw_index(data_ts, .sweep_idx = FALSE) # Returns regularized index
#' sw_index(data_ts, .sweep_idx = TRUE)  # Returns original time-based index vector
#'
#' # Coercing back to tbl
#' sw_tbl(data_ts, .sweep_idx = FALSE) # Returns regularized tbl
#' sw_tbl(data_ts, .sweep_idx = TRUE)  # Returns time-based tbl
#'
#' # Coerce to xts
#' data_ts %>%
#'     sw_xts(order.by = sw_index(., .sweep_idx = TRUE))
#'
#' # Coerce to zoo
#' data_ts %>%
#'     sw_zoo(order.by = sw_index(., .sweep_idx = TRUE))
#'
#'
#' @export
sw_index <- function(data, .sweep_idx = FALSE) {
    UseMethod("sw_index", data)
}


#' @export
sw_index.data.frame <- function(data, .sweep_idx = FALSE) {

    date_var <- get_date_variables(data)

    if (length(date_var) == 0) stop("No date or date-time identified.")

    date_var <- date_var[[1]]

    # Get contents of date_var column
    ret <- data[[date_var]]

    return(ret)

}

#' @export
sw_index.ts <- function(data, .sweep_idx = FALSE) {

    sweep_idx <- attr(data, "index")

    if (.sweep_idx && !is.null(sweep_idx)) {
        # Return sweep "time-based" index

        # Coerce numeric date to date-time
        ret <- attr(data, "index") %>%
            lubridate::as_datetime()

        # Set time class to date if Date class
        tclass <- attr(attr(data, "index"), "tclass")
        if (tclass == "Date") ret <- lubridate::as_date(ret)

        # Set the timezone
        tzone <- attr(attr(data, "index"), "tzone")
        lubridate::tz(ret) <- tzone
    }

    if (.sweep_idx && is.null(sweep_idx)) {
        warning("sweep attribute `index` not found. Returning default instead.")
        .sweep_idx = FALSE
    }

    if (!.sweep_idx) {
        # Return default index
        ret <- zoo::index(data)
    }


    return(ret)

}

#' @export
sw_index.zoo <- function(data, .sweep_idx = FALSE) {

    ret <- sw_xts(data) %>%
        sw_index()

    return(ret)

}

#' @export
sw_index.zooreg <- function(data, .sweep_idx = FALSE) {

    sweep_idx <- rownames(data)
    first_val <- sweep_idx[[1]]

    if (.sweep_idx && !is.null(sweep_idx)) {
        # Return sweep "time-based" index

        # Coerce character date to date-time
        len <- stringr::str_length(first_val)
        if (len > 10) {
            # date-time
            ret <- rownames(data) %>%
                lubridate::as_datetime()
        } else {
            # date
            ret <- rownames(data) %>%
                lubridate::as_date()
        }
    }

    if (.sweep_idx && is.null(sweep_idx)) {
        warning("sweep attribute `index` not found. Returning default instead.")
        .sweep_idx = FALSE
    }

    if (!.sweep_idx) {
        # Return default index
        ret <- zoo::index(data)
    }

    return(ret)

}

#' @export
sw_index.xts <- function(data, .sweep_idx = FALSE) {

    if (is.null(attr(data, "index"))) {
        stop("Attribute `index` not found.")
    }

    # Coerce numeric class to date-time
    ret <- attr(data, "index") %>%
        lubridate::as_datetime()

    # Set time class to date if Date class
    tclass <- xts::tclass(data)
    if (tclass == "Date") ret <- lubridate::as_date(ret)

    # Set the timezone
    tzone <- xts::tzone(data)
    lubridate::tz(ret) <- tzone

    return(ret)

}

#' @export
sw_index.forecast <- function(data, .sweep_idx = FALSE) {
    sw_index(data$x, .sweep_idx)
}

#' @export
sw_index.Arima <- function(data, .sweep_idx = FALSE) {
    sw_index(data$x, .sweep_idx)
}

#' @export
sw_index.ets <- function(data, .sweep_idx = FALSE) {
    sw_index(data$x, .sweep_idx)
}

#' @export
sw_index.stl <- function(data, .sweep_idx = FALSE) {
    sw_index(data$x, .sweep_idx)
}

#' @export
sw_index.stlm <- function(data, .sweep_idx = FALSE) {
    sw_index(data$x, .sweep_idx)
}

#' @export
sw_index.stlf <- function(data, .sweep_idx = FALSE) {
    sw_index(data$x, .sweep_idx)
}

#' @export
sw_index.baggedETS <- function(data, .sweep_idx = FALSE) {
    sw_index(data$y, .sweep_idx)
}

#' @export
sw_index.fracdiff <- function(data, .sweep_idx = FALSE) {
    sw_index(data$x, .sweep_idx)
}

#' @export
sw_index.bats <- function(data, .sweep_idx = FALSE) {
    sw_index(data$y, .sweep_idx)
}

#' @export
sw_index.HoltWinters <- function(data, .sweep_idx = FALSE) {
    sw_index(data$x, .sweep_idx)
}

#' @export
sw_index.nnetar <- function(data, .sweep_idx = FALSE) {
    sw_index(data$x, .sweep_idx)
}

#' @export
sw_index.StructTS <- function(data, .sweep_idx = FALSE) {
    sw_index(data$x, .sweep_idx)
}

#' @export
sw_index.default <- function(data, .sweep_idx = FALSE) {
    warning(paste0("`sw_index` is not designed to work with objects of class ", class(data), "."))
    invisible(data)
}


