#' Extract an index of date or datetime from time series objects, models, forecasts
#'
#' @name sw_index
#'
#' @param data A time-based tibble, time-series object, time-series model,
#' or `forecast` object.
#' @param .sweep_idx
#' If `.sweep_idx` is `TRUE` a sweep time-based index attribute is attempted to be returned.
#' If `FALSE` the default index is returned. See discussion below for further details.
#' @param silent Used to toggle printing of messages and warnings.
#'
#' @return Returns a vector of date or date times
#'
#' @details
#' `sw_index()` is used to extract the date or datetime index from various
#' time series objects, models and forecasts.
#' The method can be used on `tbl`, `xts`, `zoo`, `zooreg`, and `ts` objects.
#' The method can additionally be used on `forecast` objects and a number of
#' objects generated by modeling functions such as `Arima`, `ets`, and `HoltWinters`
#' classes to get the index of the underlying data.
#'
#' The boolean `.sweep_idx` argument is applicable to regularized time series objects
#' such as `ts` and `zooreg` classes that have both a regularized index and _potentially_
#' a "sweep index" (a time-based attribute).
#' When set to `FALSE` the regularized index is returned.
#' When set to `TRUE` the time-based sweep index is returned _if present_.
#'
#' `has_sweep_idx()` is used to determine if the object has a sweep index attribute
#' and can thus benefit from the `sw_index(.sweep_idx = TRUE)`.
#' `TRUE` indicates the "sweep index" attribute is present.
#' `FALSE` indicates the "sweep index" attribute is not present.
#' If `FALSE`, the `sw_index()` function will return the default index for the data type.
#'
#' __Important Note__: To gain the benefit of `.sweep_idx` the time series
#' must have a sweep index.
#' Use `has_sweep_idx` to determine if the object has a sweep index.
#' This is particularly important for `ts` objects, which
#' by default do not contain a time-based index and therefore must be coerced from time-based
#' objects such as `tbl`, `xts`, or `zoo` using the `sw_ts()` function in order
#' to get the "sweep index" attribute.
#' Refer to [sw_ts()] for creating persistent date / datetime index
#' during coercion to `ts`.
#'
#'
#'
#' @seealso [sw_ts()], [sw_tbl()], [sw_xts()], [sw_zoo()], [sw_zooreg()]
#'
#' @examples
#' library(tidyverse)
#' library(sweep)
#'
#' # Create time-based tibble
#' data_tbl <- tibble::tibble(
#'     date = seq.Date(from = as.Date("2000-01-01"), by = 1, length.out = 5),
#'     x    = rnorm(5) * 10,
#'     y    = 5:1
#' )
#' sw_index(data_tbl) # Returns time-based index vector
#'
#' # Coerce to ts using sw_ts(): Preserves time-basis
#' data_ts <- sw_ts(data_tbl)
#' sw_index(data_ts, .sweep_idx = FALSE) # Returns regularized index
#' sw_index(data_ts, .sweep_idx = TRUE)  # Returns original time-based index vector
#'
#' # Coercing back to tbl
#' sw_tbl(data_ts, .sweep_idx = FALSE) # Returns regularized tbl
#' sw_tbl(data_ts, .sweep_idx = TRUE)  # Returns time-based tbl
#'
#'
#'
NULL

# FUNCTION sw_index() -----

#' @export
#' @rdname sw_index
sw_index <- function(data, .sweep_idx = FALSE, silent = FALSE) {
    UseMethod("sw_index", data)
}


#' @export
sw_index.data.frame <- function(data, .sweep_idx = FALSE, silent = FALSE) {

    date_var <- get_date_variables(data)

    if (length(date_var) == 0) stop("No date or date-time identified.")

    date_var <- date_var[[1]]

    # Get contents of date_var column
    ret <- data[[date_var]]

    return(ret)

}

#' @export
sw_index.ts <- function(data, .sweep_idx = FALSE, silent = FALSE) {

    sweep_idx <- attr(data, "index")

    if (.sweep_idx && !is.null(sweep_idx)) {
        # Return sweep "time-based" index

        # Coerce numeric date to date-time
        ret <- attr(data, "index") %>%
            lubridate::as_datetime()

        # Set time class to date if Date class
        tclass <- attr(attr(data, "index"), "tclass")
        if (!is.null(tclass))
            if (tclass == "Date") ret <- lubridate::as_date(ret)
        class <- attr(attr(data, "index"), "class")
        if (!is.null(class))
            if (class == "Date") ret <- lubridate::as_date(ret)

        # Set the timezone
        tzone <- attr(attr(data, "index"), "tzone")
        if (!is.null(tzone))
            lubridate::tz(ret) <- tzone

    }

    if (.sweep_idx && is.null(sweep_idx)) {
        if (!silent) warning("sweep attribute `index` not found. Returning default instead.")
        .sweep_idx = FALSE
    }

    if (!.sweep_idx) {
        # Return default index
        ret <- zoo::index(data)
    }


    return(ret)

}

#' @export
sw_index.zoo <- function(data, .sweep_idx = FALSE, silent = FALSE) {

    ret <- sw_xts(data, silent = silent) %>%
        sw_index()

    return(ret)

}

#' @export
sw_index.zooreg <- function(data, .sweep_idx = FALSE, silent = FALSE) {

    sweep_idx <- rownames(data)
    first_val <- sweep_idx[[1]]

    if (.sweep_idx && !is.null(sweep_idx)) {
        # Return sweep "time-based" index

        # Coerce character date to date-time
        len <- stringr::str_length(first_val)
        if (len > 10) {
            # date-time
            ret <- rownames(data) %>%
                lubridate::as_datetime()
        } else {
            # date
            ret <- rownames(data) %>%
                lubridate::as_date()
        }
    }

    if (.sweep_idx && is.null(sweep_idx)) {
        if (!silent) warning("sweep attribute `index` not found. Returning default instead.")
        .sweep_idx = FALSE
    }

    if (!.sweep_idx) {
        # Return default index
        ret <- zoo::index(data)
    }

    return(ret)

}

#' @export
sw_index.xts <- function(data, .sweep_idx = FALSE, silent = FALSE) {

    if (is.null(attr(data, "index"))) {
        stop("Attribute `index` not found.")
    }

    # Coerce numeric class to date-time
    ret <- attr(data, "index") %>%
        lubridate::as_datetime()

    # Set time class to date if Date class
    tclass <- xts::tclass(data)
    if (tclass == "Date") ret <- lubridate::as_date(ret)

    # Set the timezone
    tzone <- xts::tzone(data)
    lubridate::tz(ret) <- tzone

    return(ret)

}

#' @export
sw_index.forecast <- function(data, .sweep_idx = FALSE, silent = FALSE) {
    sw_index(data$x, .sweep_idx, silent)
}

#' @export
sw_index.Arima <- function(data, .sweep_idx = FALSE, silent = FALSE) {
    sw_index(data$x, .sweep_idx, silent)
}

#' @export
sw_index.ets <- function(data, .sweep_idx = FALSE, silent = FALSE) {
    sw_index(data$x, .sweep_idx, silent)
}

#' @export
sw_index.stl <- function(data, .sweep_idx = FALSE, silent = FALSE) {
    sw_index(data$time.series, .sweep_idx, silent)
}

#' @export
sw_index.stlm <- function(data, .sweep_idx = FALSE, silent = FALSE) {
    sw_index(data$x, .sweep_idx, silent)
}

#' @export
sw_index.baggedETS <- function(data, .sweep_idx = FALSE, silent = FALSE) {
    sw_index(data$y, .sweep_idx, silent)
}

#' @export
sw_index.fracdiff <- function(data, .sweep_idx = FALSE, silent = FALSE) {
    sw_index(data$x, .sweep_idx, silent)
}

#' @export
sw_index.bats <- function(data, .sweep_idx = FALSE, silent = FALSE) {
    sw_index(data$y, .sweep_idx, silent)
}

#' @export
sw_index.HoltWinters <- function(data, .sweep_idx = FALSE, silent = FALSE) {
    sw_index(data$x, .sweep_idx, silent)
}

#' @export
sw_index.nnetar <- function(data, .sweep_idx = FALSE, silent = FALSE) {
    sw_index(data$x, .sweep_idx, silent)
}

#' @export
sw_index.StructTS <- function(data, .sweep_idx = FALSE, silent = FALSE) {
    sw_index(data$data, .sweep_idx, silent)
}

#' @export
sw_index.default <- function(data, .sweep_idx = FALSE, silent = FALSE) {
    warning(paste0("`sw_index` is not designed to work with objects of class ", class(data), "."))
    invisible(data)
}

# FUNCTION has_sweep_idx() -----

#' @export
#' @rdname sw_index
has_sweep_idx <- function(data) {
    UseMethod("has_sweep_idx")
}

has_sweep_idx.data.frame <- function(data) {
    FALSE
}

has_sweep_idx.xts <- function(data) {
    FALSE
}

has_sweep_idx.zoo <- function(data) {
    FALSE
}

has_sweep_idx.zooreg <- function(data) {
    has_sweep_index <- TRUE
    if (is.null(rownames(data))) has_sweep_index <- FALSE
    return(has_sweep_index)
}

has_sweep_idx.ts <- function(data) {
    has_sweep_index <- TRUE
    if (is.null(attr(data, "index"))) has_sweep_index <- FALSE
    return(has_sweep_index)
}

#' @export
has_sweep_idx.forecast <- function(data) {
    has_sweep_idx(data$x)
}

#' @export
has_sweep_idx.Arima <- function(data) {
    has_sweep_idx(data$x)
}

#' @export
has_sweep_idx.ets <- function(data) {
    has_sweep_idx(data$x)
}

#' @export
has_sweep_idx.stl <- function(data) {
    has_sweep_idx(data$time.series)
}

#' @export
has_sweep_idx.stlm <- function(data) {
    has_sweep_idx(data$x)
}

#' @export
has_sweep_idx.baggedETS <- function(data) {
    has_sweep_idx(data$y)
}

#' @export
has_sweep_idx.fracdiff <- function(data) {
    has_sweep_idx(data$x)
}

#' @export
has_sweep_idx.bats <- function(data) {
    has_sweep_idx(data$y)
}

#' @export
has_sweep_idx.HoltWinters <- function(data) {
    has_sweep_idx(data$x)
}

#' @export
has_sweep_idx.nnetar <- function(data) {
    has_sweep_idx(data$x)
}

#' @export
has_sweep_idx.StructTS <- function(data) {
    has_sweep_idx(data$data)
}

#' @export
has_sweep_idx.default <- function(data) {
    warning(paste0("`has_sweep_idx` is not designed to work with objects of class ", class(data), "."))
    FALSE
}
